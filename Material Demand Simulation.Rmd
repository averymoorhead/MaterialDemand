---
title: "Material Demand Calculations"
author: "Avery Moorhead"
date: "`12/22/23"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = "C:/Users/avery/OneDrive/Desktop/MaterialDemand/Inputs")

#Clear objects from workspace
rm(list = ls())
#Load libraries
library(readxl)
library(data.table)
library(dplyr)
library(tidyverse)
library(triangle)
library(stringr)
library(knitr)

```

**Setup** Reading data Frames from "Capacities" and "Material Intensity. Defining technologies and scenarios


```{r message=FALSE, warning=FALSE}

input_usgs<- read.csv("input_usgs.csv")
material_intensity<- read.csv("intensity_data.csv")
initial_year<- read.csv("initial_year.csv")
multi_model_capacities<- read.csv("multi_model_capacities.csv")
all_multi_model_capacities<- read.csv("multi_model_capacities_all_models.csv")
repeat_capacities_new<- read.csv("repeat_capacities_new.csv")
distribution_fits<- read.csv("distribution_fitting_results.csv")
scenarios = c("Ref", "IRA")#Define the REPEAT scenarios to be included
 
multi_model_technologies= c("onshore wind","utility-scale solar pv", "Nuclear New", "offshore wind","Coal","Geothermal","Biomass", "Hydro", "Coal CCS", "Gas CCS", "NGGT", "NGCC", "Solar Distributed", "Bio CCS","Gas")
repeat_technologies = c("offshore wind", "onshore wind","utility-scale solar pv", "Nuclear New", "Coal","Gas")
 
repeat_scenarios = c("baseline", "ira_mid")
```

**Material intensity summary statistics and distribution fitting:** This code estimates summary statistics and fits probability distributions to material intensity data from Liang et al. (202X) and Wang et al. (202X).

```{r message=FALSE, warning=FALSE}
intensity = material_intensity 
materials <- c(unique(intensity$Material))

#Check if all material/technology scenarios are present, if not add 0.
for (material in materials) {
  for (tech in repeat_technologies){  
    check_empty_frame = subset(intensity, technology %in% tech & Material %in% material)
    if (nrow(check_empty_frame)==0){
      intensity[nrow(intensity) + 1,] <- list(tech, material, 0)
    }
  }
}

#Estimate summary statistics of material intensity data
intensity_mean_df = intensity%>% group_by(technology,Material) %>% summarise(max = max(value),min = min(value),value = mean(value)) 
intensity_mean <- subset(intensity_mean_df, technology %in% repeat_technologies) #take the mean of intensity values to get one value per tech/material combo.

intensity_mean <- intensity_mean %>%
  mutate_at(vars(value, min, max), ~ . / 1000)


#same thing but for multimodel
multi_model_intensity = material_intensity 

#Check if all material/technology scenarios are present, if not add 0.
for (material in materials) {
  for (tech in multi_model_technologies){  
    check_empty_frame = subset(multi_model_intensity, technology %in% tech & Material %in% material)
    if (nrow(check_empty_frame)==0){
      multi_model_intensity[nrow(multi_model_intensity) + 1,] <- list(tech, material, 0)
    }
  }
}

#Estimate summary statistics of material intensity data
multimodel_intensity_mean_df = multi_model_intensity%>% group_by(technology,Material) %>% summarise(max = max(value),min = min(value),value = mean(value)) 
multimodel_intensity_mean_df <- subset(multimodel_intensity_mean_df, technology %in% multi_model_technologies) #take the mean of intensity values to get one value per tech/material combo.

multi_model_intensity_mean <- multimodel_intensity_mean_df %>%
  mutate_at(vars(value, min, max), ~ . / 1000) #finding mean intensity data converting to 1000 metric tonnes 

```

**Material demand simulation (using mean material intensity values and Bistline et al. (2023) capacity):** This code simulates material demand using mean material intensity values and added capacities estimated based on Bistline et al. (2023).
```{r}
capacities_new <- subset(multi_model_capacities, technology %in% multi_model_technologies)
capacities_new <- subset(capacities_new, year %in% c(2021,2025, 2030, 2035)) 
i <- 1
Listofmaterials <- unique(trimws(multi_model_intensity_mean$Material))

invisible(
  for (material in c("Terbium", "Tin", "Vanadium", "Yttrium", "Zinc","Aluminum", "Boron", "Cadmium", "Cement", "Chromium", "Copper", "Dysprosium", "Fiberglass","Gallium", "Germanium", "Glass"
)) {
    df_int <- subset(multi_model_intensity_mean, Material %in% material)
    df_cap <- capacities_new %>% left_join(df_int, by = 'technology') 
    # Prevent negative values
    df_cap[df_cap < 0] <- 0
    
    # Calculate total demand considering min, max, and mean intensity
    df_cap$total_demand_mean <- df_cap$newval * df_cap$value
    df_cap$total_demand_min <- df_cap$newval * df_cap$min
    df_cap$total_demand_max <- df_cap$newval * df_cap$max
    
    colnames(df_cap)[colnames(df_cap) == "total_demand_mean"] <- paste0(material, "_mean")
    colnames(df_cap)[colnames(df_cap) == "total_demand_min"] <- paste0(material, "_min")
    colnames(df_cap)[colnames(df_cap) == "total_demand_max"] <- paste0(material, "_max")
    
    df_cap <- subset(df_cap, select = -c(Material, newval, value, min, max))


    if (i == 1) {
      materials_demand <- df_cap
    } else {
      materials_demand <- materials_demand %>% left_join(df_cap, by = c("scenario", "year", "technology"))
    }
    i <- i + 1
  }
)
i<-1
invisible(
  for (material in c("Manganese", "Molybdenum", "Neodymium",  "Nickel", "Niobium", "Praseodymium", "Selenium", "Silicon", "Silver", "Steel", "Tellurium", "Indium", "Lead", "Magnesium"
)) {
    df_int <- subset(multi_model_intensity_mean, Material %in% material)
    df_cap <- capacities_new %>% left_join(df_int, by = 'technology') 
    # Prevent negative values
    df_cap[df_cap < 0] <- 0

    
    # Calculate total demand considering min, max, and mean intensity
    df_cap$total_demand_mean <- df_cap$newval * df_cap$value
    df_cap$total_demand_min <- df_cap$newval * df_cap$min
    df_cap$total_demand_max <- df_cap$newval * df_cap$max
    
    colnames(df_cap)[colnames(df_cap) == "total_demand_mean"] <- paste0(material, "_mean")
    colnames(df_cap)[colnames(df_cap) == "total_demand_min"] <- paste0(material, "_min")
    colnames(df_cap)[colnames(df_cap) == "total_demand_max"] <- paste0(material, "_max")
    
    df_cap <- subset(df_cap, select = -c(Material, newval, value, min, max))


    if (i == 1) {
      materials_demand1 <- df_cap
    } else {
      materials_demand1 <- materials_demand1 %>% left_join(df_cap, by = c("scenario", "year", "technology"))
    }
    i <- i + 1
  }
)
merged_material_demand <- merge(materials_demand, materials_demand1, by = c("year", "scenario", "technology"))
materials_demand<-merged_material_demand

#combining CCS technologies, solar technologies and gas technologies
ccs_df <- materials_demand %>% filter(technology %in% c("Gas CCS", "Coal CCS", "Solar Distributed", "NGGT", "Bio CCS"))

for (i in seq_len(nrow(ccs_df))) {
  row <- ccs_df[i, ]
  year <- row$year
  scenario <- row$scenario
  technology <- row$technology
  
  target_technology <- ifelse(technology == "Gas CCS" | technology == "NGGT", "NGCC",
                       ifelse(technology == "Coal CCS", "Coal",
                       ifelse(technology == "Bio CCS", "Biomass",
                       ifelse(technology == "Solar Distributed", "utility-scale solar pv", NA))))

  target_row_idx <- which(materials_demand$year == year & 
                          materials_demand$scenario == scenario & 
                          materials_demand$technology == target_technology)

  if (length(target_row_idx) == 1) {
    materials_demand[target_row_idx, 4:93] <- materials_demand[target_row_idx, 4:93] + row[4:93]
  }
}

materials_demand <- materials_demand %>% filter(!technology %in% c("Bio CCS", "Gas CCS", "Coal CCS", "Solar Distributed", "NGGT"))
materials_demand$technology <- gsub("NGCC", "Gas", materials_demand$technology)

```

**Material demand simulation (using mean material intensity values and Bistline et al. (2023) capacity by model):** This code simulates material demand using mean material intensity values and added capacities estimated based on Bistline et al. (2023). The simulation is done separately for each model.

```{r}
# List of models to iterate over
model_list <- c("EPS", "E4ST", "GCAM", "Haiku", "IPM-E", "IPM-N", "MARKAL", "NEMS-RHG", "ReEDS", "REGEN", "RIO")

all_models_combined <- data.frame()

for (current_model in model_list) {
  capacities_new <- subset(all_multi_model_capacities, technology %in% multi_model_technologies & model %in% current_model)
  capacities_new <- subset(capacities_new, year %in% c(2021, 2025, 2030, 2035)) 
  capacities_new <- capacities_new %>% select(-model)
  
  i <- 1
  Listofmaterials <- unique(trimws(multi_model_intensity_mean$Material))
  
  invisible(
    for (material in c("Glass", "Terbium", "Tin", "Vanadium", "Yttrium", "Zinc", "Aluminum", "Boron", "Cadmium", "Cement", "Chromium", "Copper", "Dysprosium", "Fiberglass", "Gallium", "Germanium")) {
      df_int <- subset(multi_model_intensity_mean, Material %in% material)
      df_cap <- capacities_new %>% left_join(df_int, by = 'technology') 
      df_cap[df_cap < 0] <- 0

      df_cap$total_demand_mean <- df_cap$newval * df_cap$value
      df_cap$total_demand_min <- df_cap$newval * df_cap$min
      df_cap$total_demand_max <- df_cap$newval * df_cap$max
      
      colnames(df_cap)[colnames(df_cap) == "total_demand_mean"] <- paste0(material, "_mean")
      colnames(df_cap)[colnames(df_cap) == "total_demand_min"] <- paste0(material, "_min")
      colnames(df_cap)[colnames(df_cap) == "total_demand_max"] <- paste0(material, "_max")
      
      df_cap <- subset(df_cap, select = -c(Material, newval, value, min, max))
      
      if (i == 1) {
        all_models_materials_demand <- df_cap
      } else {
        all_models_materials_demand <- all_models_materials_demand %>% left_join(df_cap, by = c("scenario", "year", "technology"))
      }
      i <- i + 1
    }
  )
  
  i <- 1
  invisible(
    for (material in c("Manganese", "Molybdenum", "Neodymium", "Nickel", "Niobium", "Praseodymium", "Selenium", "Silicon", "Silver", "Steel", "Tellurium", "Indium", "Lead", "Magnesium")) {
      df_int <- subset(multi_model_intensity_mean, Material %in% material)
      df_cap <- capacities_new %>% left_join(df_int, by = 'technology') 
      df_cap[df_cap < 0] <- 0
      
      df_cap$total_demand_mean <- df_cap$newval * df_cap$value
      df_cap$total_demand_min <- df_cap$newval * df_cap$min
      df_cap$total_demand_max <- df_cap$newval * df_cap$max
      
      colnames(df_cap)[colnames(df_cap) == "total_demand_mean"] <- paste0(material, "_mean")
      colnames(df_cap)[colnames(df_cap) == "total_demand_min"] <- paste0(material, "_min")
      colnames(df_cap)[colnames(df_cap) == "total_demand_max"] <- paste0(material, "_max")
      
      df_cap <- subset(df_cap, select = -c(Material, newval, value, min, max))
      
      if (i == 1) {
        all_models_materials_demand1 <- df_cap
      } else {
        all_models_materials_demand1 <- all_models_materials_demand1 %>% left_join(df_cap, by = c("scenario", "year", "technology"))
      }
      i <- i + 1
    }
  )
  
  all_models_merged_material_demand <- merge(all_models_materials_demand, all_models_materials_demand1, by = c("year", "scenario", "technology"))

  #combining technologies
  ccs_df <- all_models_merged_material_demand %>% filter(technology %in% c("Gas CCS", "Coal CCS", "Solar Distributed", "NGGT", "Bio CCS"))

  for (i in seq_len(nrow(ccs_df))) {
    row <- ccs_df[i, ]
    year <- row$year
    scenario <- row$scenario
    technology <- row$technology

    target_technology <- ifelse(technology == "Gas CCS" | technology == "NGGT", "NGCC",
                         ifelse(technology == "Coal CCS", "Coal",
                         ifelse(technology == "Bio CCS", "Biomass",
                         ifelse(technology == "Solar Distributed", "utility-scale solar pv", NA))))

    target_row_idx <- which(all_models_merged_material_demand$year == year & 
                            all_models_merged_material_demand$scenario == scenario & 
                            all_models_merged_material_demand$technology == target_technology)

    if (length(target_row_idx) == 1) {
      all_models_merged_material_demand[target_row_idx, 4:93] <- all_models_merged_material_demand[target_row_idx, 4:93] + row[4:93]
    }
  }

  all_models_merged_material_demand <- all_models_merged_material_demand %>% filter(!technology %in% c("Bio CCS", "Gas CCS", "Coal CCS", "Solar Distributed", "NGGT"))
  all_models_merged_material_demand$technology <- gsub("NGCC", "Gas", all_models_merged_material_demand$technology)
  all_models_merged_material_demand$model <- current_model

  if (nrow(all_models_combined) == 0) {
    all_models_combined <- all_models_merged_material_demand
  } else {
    all_models_combined <- bind_rows(all_models_combined, all_models_merged_material_demand)
  }
}
```


**Material demand simulation (using mean material intensity values and Jenkins et al. (2023) capacity):** This code simulates material demand using mean material intensity values and added capacities estimated based on Jenkins et al. (2023).
```{r}
#data processing 
repeat_capacities_new <- subset(repeat_capacities_new, technology %in% repeat_technologies)
repeat_capacities_new <- subset(repeat_capacities_new, year %in% c(2025, 2030, 2035)) 
names(repeat_capacities_new)[names(repeat_capacities_new) == "run.name"] <- "scenario"
repeat_capacities_new$scenario[repeat_capacities_new$scenario == 'ira_mid'] <- 'IRA'
repeat_capacities_new$scenario[repeat_capacities_new$scenario == 'baseline'] <- 'REF'
print(unique(repeat_capacities_new$technology))

# Material demand simulation for the first group of materials
i <- 1
invisible(
  for (material in c("Terbium", "Tin", "Vanadium", "Yttrium", "Zinc","Aluminum", "Boron", "Cadmium", "Cement", "Chromium", "Copper", "Dysprosium", "Fiberglass","Gallium", "Germanium", "Glass") ) {
    df_int <- subset(intensity_mean, Material %in% material)
    df_cap <- repeat_capacities_new %>% left_join(df_int, by = 'technology') 
    
    # Prevent negative values
    df_cap[df_cap < 0] <- 0
    
    # Calculate total demand considering min, max, and mean intensity
    df_cap$total_demand_mean <- df_cap$newval * df_cap$value
    df_cap$total_demand_min <- df_cap$newval * df_cap$min
    df_cap$total_demand_max <- df_cap$newval * df_cap$max
    
    colnames(df_cap)[colnames(df_cap) == "total_demand_mean"] <- paste0(material, "_mean")
    colnames(df_cap)[colnames(df_cap) == "total_demand_min"] <- paste0(material, "_min")
    colnames(df_cap)[colnames(df_cap) == "total_demand_max"] <- paste0(material, "_max")
    
    df_cap <- subset(df_cap, select = -c(Material, newval, value, min, max))
    
    if (i == 1) {
      repeat_materials_demand_group1 <- df_cap
    } else {
      repeat_materials_demand_group1 <- repeat_materials_demand_group1 %>% left_join(df_cap, by = c("scenario", "year", "technology"))
    }
    i <- i + 1
  }
)

# Material demand simulation for the second group of materials
i <- 1
invisible(
  for (material in c("Manganese", "Molybdenum", "Neodymium",  "Nickel", "Niobium", "Praseodymium", "Selenium", "Silicon", "Silver", "Steel", "Tellurium", "Indium", "Lead", "Magnesium"
)) {
    df_int <- subset(intensity_mean, Material %in% material)
    df_cap <- repeat_capacities_new %>% left_join(df_int, by = 'technology') 
    
    # Prevent negative values
    df_cap[df_cap < 0] <- 0
    
    # Calculate total demand considering min, max, and mean intensity
    df_cap$total_demand_mean <- df_cap$newval * df_cap$value
    df_cap$total_demand_min <- df_cap$newval * df_cap$min
    df_cap$total_demand_max <- df_cap$newval * df_cap$max
    
    colnames(df_cap)[colnames(df_cap) == "total_demand_mean"] <- paste0(material, "_mean")
    colnames(df_cap)[colnames(df_cap) == "total_demand_min"] <- paste0(material, "_min")
    colnames(df_cap)[colnames(df_cap) == "total_demand_max"] <- paste0(material, "_max")
    
    df_cap <- subset(df_cap, select = -c(Material, newval, value, min, max))
    
    if (i == 1) {
      repeat_materials_demand_group2 <- df_cap
    } else {
      repeat_materials_demand_group2 <- repeat_materials_demand_group2 %>% left_join(df_cap, by = c("scenario", "year", "technology"))
    }
    i <- i + 1
  }
)

# Merge the results for both groups
merged_material_demand <- merge(repeat_materials_demand_group1, repeat_materials_demand_group2, by = c("year", "scenario", "technology"))
repeat_materials_demand <- merged_material_demand

```

**Material intensity distribution fitting and simulation** In this code, 1000 values material intensity values are generated for each material/technology combination. This code is specifically for the Bistline et al., (202x) results.
```{r}
materials <- c(unique(intensity$Material))
n <- 1 # number of iterations
df_mc <- data.frame() 
print(materials)
for (mat in materials) {
  for (tech in multi_model_technologies) {
    loc <- subset(intensity, Material %in% mat & technology %in% tech)
    if (nrow(loc) > 1) {
      
      tryCatch({
        distribution_info <- subset(distribution_fits, Material == mat & technology == tech)$Distribution
      }, error = function(e) {
        distribution_info <- NA
      })
      
      if (length(distribution_info) == 0) {  # Handle empty dataframe
        distribution_info <- NA
      }
      
      if (is.na(distribution_info)) {  # If no distribution info found, default to normal
        distribution_info <- "normal"
      }
      
      minv <- min(loc$value)
      maxv <- max(loc$value)
      meanv <- mean(loc$value)
      index_name <- paste(mat, gsub("[[:space:]]", ".", tech), sep = ".") # addressing issues with spaces and dashes
      index_name <- gsub("-", ".", index_name)
      df2 <- data.frame(index = index_name, min = minv, max = maxv, mean = meanv)
      
      if (n == 1) {
        mc_values <- df2
      } else {
        mc_values <- rbind(mc_values, df2)
      }
      
      # Generate values based on the distribution type
      if (distribution_info == "triangular") {
        result <- rtriangle(1000, minv, maxv, meanv)
      } else if (distribution_info == "gauss") {
        result <- rnorm(1000, mean = meanv, sd = (maxv - minv) / 6)
      } else if (distribution_info == "weibull") {
        result <- rweibull(1000, shape = 1.5, scale = meanv)
      } else if (distribution_info == "gamma") {
        result <- rgamma(1000, shape = 1.5, scale = meanv / 1.5)
      } else {
        warning(paste("Distribution", distribution_info, " Defaulting to normal distribution."))
        result <- rnorm(1000, mean = meanv, sd = (maxv - minv) / 6)
      }
      
      # Check if result is negative and replace with 0
      result[result < 0] <- 0
      
      if (n == 1) {
        df_mc <- data.frame(result)
      } else {
        df_mc <- cbind(df_mc, result)
      }
      colnames(df_mc)[colnames(df_mc) == "result"] <- index_name
      n <- n + 1
    }
  }
}
```


**Material demand simulation (using material intensity distributions and Bistline et al. (2023) capacity):** This code simulates material demand using fitted material intensity distributions and added capacities estimated based on Bistline et al. (202x).
```{r}
#data processing
 capacities_new <- subset(multi_model_capacities, technology %in% multi_model_technologies)
 capacities_new <- subset(capacities_new, year %in% c(2021,2025, 2030, 2035)) # Subset for specific years

subset_capacities<- capacities_new 
melted_df_mc <- df_mc %>%
  mutate(row_id = row_number()) %>%
  pivot_longer(cols = -row_id, names_to = "Material_Technology", values_to = "Intensity_Distribution_Value") %>%
  mutate(Technology = gsub("^[^.]+\\.", "", Material_Technology),  # Extract word after the first dot
         Technology = gsub("\\.", " ", Technology))  # Replace periods with spaces
melted_df_mc <- melted_df_mc %>%
  rename(technology = Technology)
melted_df_mc$technology <- gsub("utility scale solar pv", "utility-scale solar pv", melted_df_mc$technology)
print(unique(melted_df_mc$Material_Technology))
melted_df_mc <- melted_df_mc %>%
  filter(technology %in% multi_model_technologies)
subset_capacities <- subset_capacities %>%
     filter(technology %in% unique(melted_df_mc$technology))
melted_df_mc <- melted_df_mc %>%
  filter(technology %in% unique(subset_capacities$technology))

#mulitply intensity values by capacity
mc_material_demand <- merge(melted_df_mc, subset_capacities, by = "technology")
mc_material_demand$material_demand = mc_material_demand$Intensity_Distribution_Value *mc_material_demand$newval
mc_material_demand$material_demand <- ifelse(mc_material_demand$material_demand < 0, 0, mc_material_demand$material_demand)
mc_material_demand <- mc_material_demand %>%
  rename(capacity_new = newval)
mc_material_demand <- mc_material_demand %>%
  mutate(Material = str_extract(Material_Technology, "\\w+"))

```
**Material intensity distribution fitting and simulation** In this code, 1000 values material intensity values are generated for each material/technology combination. This code is specifically for the Jenkins et al., (2023) results.

```{r}
#same thing but for repeat
materials <- c(unique(intensity$Material))
print(materials)
n <- 1 
df_mc <- data.frame() 

for (mat in materials) {
  for (tech in repeat_technologies) {
    loc <- subset(intensity, Material %in% mat & technology %in% tech)
    if (nrow(loc) > 1) {
      
      tryCatch({
        distribution_info <- subset(distribution_fits, Material == mat & technology == tech)$Distribution
      }, error = function(e) {
        distribution_info <- NA
      })
      
      if (length(distribution_info) == 0) {  # Handle empty dataframe
        distribution_info <- NA
      }
      
      if (is.na(distribution_info)) {  # If no distribution info found, default to normal
        distribution_info <- "normal"
      }
      
      minv <- min(loc$value)
      maxv <- max(loc$value)
      meanv <- mean(loc$value)
      index_name <- paste(mat, gsub("[[:space:]]", ".", tech), sep = ".") # addressing issues with spaces and dashes
      index_name <- gsub("-", ".", index_name)
      df2 <- data.frame(index = index_name, min = minv, max = maxv, mean = meanv)
      
      if (n == 1) {
        mc_values <- df2
      } else {
        mc_values <- rbind(mc_values, df2)
      }
      
      # Generate values based on the distribution type
      if (distribution_info == "triangular") {
        result <- rtriangle(1000, minv, maxv, meanv)
      } else if (distribution_info == "gauss") {
        result <- rnorm(1000, mean = meanv, sd = (maxv - minv) / 6)
      } else if (distribution_info == "weibull") {
        result <- rweibull(1000, shape = 1.5, scale = meanv)
      } else if (distribution_info == "gamma") {
        result <- rgamma(1000, shape = 1.5, scale = meanv / 1.5)
      } else {
        warning(paste("Distribution", distribution_info, " Defaulting to normal distribution."))
        result <- rnorm(1000, mean = meanv, sd = (maxv - minv) / 6)
      }
      
      # Check if result is negative and replace with 0
      result[result < 0] <- 0
      
      if (n == 1) {
        df_mc <- data.frame(result)
      } else {
        df_mc <- cbind(df_mc, result)
      }
      colnames(df_mc)[colnames(df_mc) == "result"] <- index_name
      n <- n + 1
    }
  }
}
```

**Material demand simulation (using material intensity distributions and Jenkins et al. (2023) capacity):** This code simulates material demand using fitted material intensity distributions and added capacities estimated based on Jenkins et al. (2023).

```{r}
#Data processing 
subset_capacities<- repeat_capacities_new 
melted_df_mc <- df_mc %>%
  mutate(row_id = row_number()) %>%
  pivot_longer(cols = -row_id, names_to = "Material_Technology", values_to = "Intensity_Distribution_Value") %>%
  mutate(Technology = gsub("^[^.]+\\.", "", Material_Technology),  # Extract word after the first dot
         Technology = gsub("\\.", " ", Technology))  # Replace periods with spaces
melted_df_mc <- melted_df_mc %>%
  rename(technology = Technology)
melted_df_mc$technology <- gsub("utility scale solar pv", "utility-scale solar pv", melted_df_mc$technology)
melted_df_mc <- melted_df_mc %>%
  filter(technology %in% c("utility-scale solar pv", "onshore wind", "offshore wind", "Nuclear New", "Gas"))
print(repeat_technologies)
subset_capacities <- subset_capacities %>%
  filter(technology %in% unique(melted_df_mc$technology))
melted_df_mc <- melted_df_mc %>%
  filter(technology %in% unique(subset_capacities$technology))

#multiply simulated intensities by capacit 
repeat_mc_material_demand <- merge(melted_df_mc, subset_capacities, by = "technology")
repeat_mc_material_demand$material_demand = repeat_mc_material_demand$Intensity_Distribution_Value *repeat_mc_material_demand$newval
repeat_mc_material_demand$material_demand <- ifelse(repeat_mc_material_demand$material_demand < 0, 0, repeat_mc_material_demand$material_demand)
repeat_mc_material_demand <- repeat_mc_material_demand %>%
  rename(capacity_new = newval)
repeat_mc_material_demand <- repeat_mc_material_demand %>%
  mutate(Material = str_extract(Material_Technology, "\\w+"))

```
**Summing Simulated Material Demand ** This code sums the simulated material demand from both Bistline et al. (202x) and Jenkins et al. (2023) to find total material demand 
```{r}
#Bistline material demand 
mc_material_demand_total <- mc_material_demand %>%
  select(-capacity_new, -Intensity_Distribution_Value) %>%  
  pivot_wider(
    id_cols = c(row_id, year, scenario, Material),  
    names_from = technology, 
    values_from = material_demand,
    values_fill = 0  # Fill missing values with 0
  )
mc_material_demand_total <- mc_material_demand_total %>%
  mutate(
    total_demand = rowSums(select(., 
                                   c(Biomass, 'Bio CCS', Coal, 'Coal CCS', 'Gas CCS', NGGT,NGCC, Hydro, `Nuclear New`, `onshore wind`, `utility-scale solar pv`,'Solar Distributed')))
  )

#Jenkins et al. material demand
repeat_mc_material_demand_total <- repeat_mc_material_demand %>%
  select(-capacity_new, -Intensity_Distribution_Value) %>%  
  pivot_wider(
    id_cols = c(row_id, year, scenario, Material),  
    names_from = technology, 
    values_from = material_demand,
    values_fill = 0  
  )
repeat_mc_material_demand_total <- repeat_mc_material_demand_total %>%
  mutate(
    total_demand = rowSums(select(., 
                                   c(`Gas`, `Nuclear New`, `onshore wind`, `offshore wind`, `utility-scale solar pv`)))
  )

```

**Saving data frames to "outputs" folder:** This code saves the dataframes for use in the model 

```{r}
folder_path <- "C:/Users/avery/OneDrive/Desktop/MaterialDemand/Outputs"
file_path2 <- file.path(folder_path, "simulated_intensity")
file_path3 <- file.path(folder_path, "multi_model_mc_material_demand.csv")
file_path4 <- file.path(folder_path, "repeat_mc_material_demand.csv")
file_path5 <- file.path(folder_path, "materials_demand.csv")
file_path6 <- file.path(folder_path, "repeat_materials_demand.csv")
file_path7 <- file.path(folder_path, "repeat_mc_material_demand_total.csv")
file_path8 <- file.path(folder_path, "multi_model_mc_material_demand_total.csv")
file_path9 <- file.path(folder_path, "intensity_mean.csv")
file_path10 <- file.path(folder_path, "all_models_material_demand.csv")


# Write each dataframe to its respective CSV file in the outputs folder
write.csv(df_mc, file = file_path2, row.names = FALSE)
write.csv(mc_material_demand, file = file_path3, row.names = FALSE)
write.csv(repeat_mc_material_demand, file = file_path4, row.names = FALSE)
write.csv(materials_demand, file = file_path5, row.names = FALSE)
write.csv(repeat_materials_demand, file = file_path6, row.names = FALSE)
write.csv(repeat_mc_material_demand_total, file = file_path7, row.names = FALSE)
write.csv(mc_material_demand_total, file = file_path8, row.names = FALSE)
write.csv(intensity_mean, file = file_path9, row.names = FALSE)
write.csv(all_models_combined, file = file_path10, row.names = FALSE)

```

