---
title: "Material Demand Calculations"
author: "Avery Moorhead"
date: "`12/22/23"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = "C:/Users/avery/OneDrive/Desktop/MaterialDemand/Inputs")

###NTS: Currently only running this script on aluminum cement and steel. you can change this by changing rows 222,305, and 341
#Clear objects from workspace
rm(list = ls())
#Load libraries
library(readxl)
library(data.table)
library(dplyr)
library(tidyverse)
library(triangle)
library(stringr)
library(knitr)

```

**Setup** Reading data Frames from "Capacities" and "Material Intensity. Defining technologies and scenarios


```{r message=FALSE, warning=FALSE}
# Print the current working directory
print(getwd())
input_usgs<- read.csv("input_usgs.csv")
material_intensity<- read.csv("intensity_data.csv")
initial_year<- read.csv("initial_year.csv")
multi_model_capacities<- read.csv("multi_model_capacities.csv")
all_multi_model_capacities<- read.csv("mutli_model_capacities_all_models.csv")

repeat_capacities_new<- read.csv("repeat_capacities_new.csv")
distribution_fits<- read.csv("distribution_fitting_results.csv")

scenarios = c("Ref", "IRA")#Define the REPEAT scenarios to be included
 

multi_model_technologies= c("onshore wind","utility-scale solar pv", "Nuclear New", "offshore wind","Coal","Geothermal","Biomass", "Hydro", "Coal CCS", "Gas CCS", "NGGT", "NGCC", "Solar Distributed", "Bio CCS","Gas")
 repeat_technologies = c("offshore wind", "onshore wind","utility-scale solar pv", "Nuclear New", "Coal","Gas")
 

                       
                        #"Coal","Geothermal","Biomass","Gas", "Hydro")#Define the REPEAT technologies to be included
repeat_scenarios = c("baseline", "ira_mid")
usgs_variables = c("Consumption - US", "Production - US", "Import - US", "Export - US")


```

**Material intensity summary statistics and distribution fitting:** This code estimates summary statistics and fits probability distributions to material intensity data from Liang et al. (202X) and Wang et al. (202X).

```{r message=FALSE, warning=FALSE}
intensity = material_intensity 
materials <- c(unique(intensity$Material))
print(materials)

#Check if all material/technology scenarios are present, if not add 0.
for (material in materials) {
  for (tech in repeat_technologies){  
    check_empty_frame = subset(intensity, technology %in% tech & Material %in% material)
    if (nrow(check_empty_frame)==0){
      intensity[nrow(intensity) + 1,] <- list(tech, material, 0)
    }
  }
}

#Estimate summary statistics of material intensity data
intensity_mean_df = intensity%>% group_by(technology,Material) %>% summarise(max = max(value),min = min(value),value = mean(value)) 
intensity_mean <- subset(intensity_mean_df, technology %in% repeat_technologies) #take the mean of intensity values to get one value per tech/material combo.

intensity_mean <- intensity_mean %>%
  mutate_at(vars(value, min, max), ~ . / 1000)
#same thing but for multimodel
multi_model_intensity = material_intensity 

#Check if all material/technology scenarios are present, if not add 0.
for (material in materials) {
  for (tech in multi_model_technologies){  
    check_empty_frame = subset(multi_model_intensity, technology %in% tech & Material %in% material)
    if (nrow(check_empty_frame)==0){
      multi_model_intensity[nrow(multi_model_intensity) + 1,] <- list(tech, material, 0)
    }
  }
}

#Estimate summary statistics of material intensity data
multimodel_intensity_mean_df = multi_model_intensity%>% group_by(technology,Material) %>% summarise(max = max(value),min = min(value),value = mean(value)) 
multimodel_intensity_mean_df <- subset(multimodel_intensity_mean_df, technology %in% multi_model_technologies) #take the mean of intensity values to get one value per tech/material combo.

multi_model_intensity_mean <- multimodel_intensity_mean_df %>%
  mutate_at(vars(value, min, max), ~ . / 1000)


```

**Material demand simulation (using mean material intensity values and Bistline et al. (2023) capacity):** This code simulates material demand using mean material intensity values and added capacities estimated based on Bistline et al. (2023).
```{r}
# Material demand simulation
#print(unique(capacities_new$technology))

 capacities_new <- subset(multi_model_capacities, technology %in% multi_model_technologies)
 capacities_new <- subset(capacities_new, year %in% c(2021,2025, 2030, 2035)) # Subset for specific years
i <- 1
#print(unique(intensity_mean$Material))
Listofmaterials <-unique(multi_model_intensity_mean$Material)
Listofmaterials <- unique(trimws(multi_model_intensity_mean$Material))

invisible(
  for (material in c("Terbium", "Tin", "Vanadium", "Yttrium", "Zinc","Aluminum", "Boron", "Cadmium", "Cement", "Chromium", "Copper", "Dysprosium", "Fiberglass","Gallium", "Germanium", "Glass"
)) {
    #print(material)

   # material = "Aluminum"
    df_int <- subset(multi_model_intensity_mean, Material %in% material)
    df_cap <- capacities_new %>% left_join(df_int, by = 'technology') 
    # Prevent negative values
    df_cap[df_cap < 0] <- 0

    
    # Calculate total demand considering min, max, and mean intensity
    df_cap$total_demand_mean <- df_cap$newval * df_cap$value
    df_cap$total_demand_min <- df_cap$newval * df_cap$min
    df_cap$total_demand_max <- df_cap$newval * df_cap$max
    
    colnames(df_cap)[colnames(df_cap) == "total_demand_mean"] <- paste0(material, "_mean")
    colnames(df_cap)[colnames(df_cap) == "total_demand_min"] <- paste0(material, "_min")
    colnames(df_cap)[colnames(df_cap) == "total_demand_max"] <- paste0(material, "_max")
    
    df_cap <- subset(df_cap, select = -c(Material, newval, value, min, max))


    if (i == 1) {
      materials_demand <- df_cap
    } else {
      materials_demand <- materials_demand %>% left_join(df_cap, by = c("scenario", "year", "technology"))
    }
    i <- i + 1
  }
)
i<-1
invisible(
  for (material in c("Manganese", "Molybdenum", "Neodymium",  "Nickel", "Niobium", "Praseodymium", "Selenium", "Silicon", "Silver", "Steel", "Tellurium", "Indium", "Lead", "Magnesium"
)) {
    #print(material)

   # material = "Aluminum"
    df_int <- subset(multi_model_intensity_mean, Material %in% material)
    df_cap <- capacities_new %>% left_join(df_int, by = 'technology') 
    # Prevent negative values
    df_cap[df_cap < 0] <- 0

    
    # Calculate total demand considering min, max, and mean intensity
    df_cap$total_demand_mean <- df_cap$newval * df_cap$value
    df_cap$total_demand_min <- df_cap$newval * df_cap$min
    df_cap$total_demand_max <- df_cap$newval * df_cap$max
    
    colnames(df_cap)[colnames(df_cap) == "total_demand_mean"] <- paste0(material, "_mean")
    colnames(df_cap)[colnames(df_cap) == "total_demand_min"] <- paste0(material, "_min")
    colnames(df_cap)[colnames(df_cap) == "total_demand_max"] <- paste0(material, "_max")
    
    df_cap <- subset(df_cap, select = -c(Material, newval, value, min, max))


    if (i == 1) {
      materials_demand1 <- df_cap
    } else {
      materials_demand1 <- materials_demand1 %>% left_join(df_cap, by = c("scenario", "year", "technology"))
    }
    i <- i + 1
  }
)
merged_material_demand <- merge(materials_demand, materials_demand1, by = c("year", "scenario", "technology"))
materials_demand<-merged_material_demand

ccs_df <- materials_demand %>% filter(technology %in% c("Gas CCS", "Coal CCS", "Solar Distributed", "NGGT", "Bio CCS"))

for (i in seq_len(nrow(ccs_df))) {
  row <- ccs_df[i, ]
  year <- row$year
  scenario <- row$scenario
  technology <- row$technology
  
  target_technology <- ifelse(technology == "Gas CCS" | technology == "NGGT", "NGCC",
                       ifelse(technology == "Coal CCS", "Coal",
                       ifelse(technology == "Bio CCS", "Biomass",
                       ifelse(technology == "Solar Distributed", "utility-scale solar pv", NA))))

  target_row_idx <- which(materials_demand$year == year & 
                          materials_demand$scenario == scenario & 
                          materials_demand$technology == target_technology)

  if (length(target_row_idx) == 1) {
    materials_demand[target_row_idx, 4:93] <- materials_demand[target_row_idx, 4:93] + row[4:93]
  }
}

materials_demand <- materials_demand %>% filter(!technology %in% c("Bio CCS", "Gas CCS", "Coal CCS", "Solar Distributed", "NGGT"))
materials_demand$technology <- gsub("NGCC", "Gas", materials_demand$technology)


print(unique(materials_demand$technology))

print(unique(capacities_new$technology))




```


```{r}
# List of models to iterate over
model_list <- c("EPS", "E4ST", "GCAM", "Haiku", "IPM-E", "IPM-N", "MARKAL", "NEMS-RHG", "ReEDS", "REGEN", "RIO")

# Placeholder for combined results
all_models_combined <- data.frame()

for (current_model in model_list) {
  capacities_new <- subset(all_multi_model_capacities, technology %in% multi_model_technologies & model %in% current_model)
  capacities_new <- subset(capacities_new, year %in% c(2021, 2025, 2030, 2035)) 
  capacities_new <- capacities_new %>% select(-model)
  
  i <- 1
  Listofmaterials <- unique(trimws(multi_model_intensity_mean$Material))
  
  invisible(
    for (material in c("Glass", "Terbium", "Tin", "Vanadium", "Yttrium", "Zinc", "Aluminum", "Boron", "Cadmium", "Cement", "Chromium", "Copper", "Dysprosium", "Fiberglass", "Gallium", "Germanium")) {
      df_int <- subset(multi_model_intensity_mean, Material %in% material)
      df_cap <- capacities_new %>% left_join(df_int, by = 'technology') 
      df_cap[df_cap < 0] <- 0

      df_cap$total_demand_mean <- df_cap$newval * df_cap$value
      df_cap$total_demand_min <- df_cap$newval * df_cap$min
      df_cap$total_demand_max <- df_cap$newval * df_cap$max
      
      colnames(df_cap)[colnames(df_cap) == "total_demand_mean"] <- paste0(material, "_mean")
      colnames(df_cap)[colnames(df_cap) == "total_demand_min"] <- paste0(material, "_min")
      colnames(df_cap)[colnames(df_cap) == "total_demand_max"] <- paste0(material, "_max")
      
      df_cap <- subset(df_cap, select = -c(Material, newval, value, min, max))
      
      if (i == 1) {
        all_models_materials_demand <- df_cap
      } else {
        all_models_materials_demand <- all_models_materials_demand %>% left_join(df_cap, by = c("scenario", "year", "technology"))
      }
      i <- i + 1
    }
  )
  
  i <- 1
  invisible(
    for (material in c("Manganese", "Molybdenum", "Neodymium", "Nickel", "Niobium", "Praseodymium", "Selenium", "Silicon", "Silver", "Steel", "Tellurium", "Indium", "Lead", "Magnesium")) {
      df_int <- subset(multi_model_intensity_mean, Material %in% material)
      df_cap <- capacities_new %>% left_join(df_int, by = 'technology') 
      df_cap[df_cap < 0] <- 0
      
      df_cap$total_demand_mean <- df_cap$newval * df_cap$value
      df_cap$total_demand_min <- df_cap$newval * df_cap$min
      df_cap$total_demand_max <- df_cap$newval * df_cap$max
      
      colnames(df_cap)[colnames(df_cap) == "total_demand_mean"] <- paste0(material, "_mean")
      colnames(df_cap)[colnames(df_cap) == "total_demand_min"] <- paste0(material, "_min")
      colnames(df_cap)[colnames(df_cap) == "total_demand_max"] <- paste0(material, "_max")
      
      df_cap <- subset(df_cap, select = -c(Material, newval, value, min, max))
      
      if (i == 1) {
        all_models_materials_demand1 <- df_cap
      } else {
        all_models_materials_demand1 <- all_models_materials_demand1 %>% left_join(df_cap, by = c("scenario", "year", "technology"))
      }
      i <- i + 1
    }
  )
  
  all_models_merged_material_demand <- merge(all_models_materials_demand, all_models_materials_demand1, by = c("year", "scenario", "technology"))

  ccs_df <- all_models_merged_material_demand %>% filter(technology %in% c("Gas CCS", "Coal CCS", "Solar Distributed", "NGGT", "Bio CCS"))

  for (i in seq_len(nrow(ccs_df))) {
    row <- ccs_df[i, ]
    year <- row$year
    scenario <- row$scenario
    technology <- row$technology

    target_technology <- ifelse(technology == "Gas CCS" | technology == "NGGT", "NGCC",
                         ifelse(technology == "Coal CCS", "Coal",
                         ifelse(technology == "Bio CCS", "Biomass",
                         ifelse(technology == "Solar Distributed", "utility-scale solar pv", NA))))

    target_row_idx <- which(all_models_merged_material_demand$year == year & 
                            all_models_merged_material_demand$scenario == scenario & 
                            all_models_merged_material_demand$technology == target_technology)

    if (length(target_row_idx) == 1) {
      all_models_merged_material_demand[target_row_idx, 4:93] <- all_models_merged_material_demand[target_row_idx, 4:93] + row[4:93]
    }
  }

  all_models_merged_material_demand <- all_models_merged_material_demand %>% filter(!technology %in% c("Bio CCS", "Gas CCS", "Coal CCS", "Solar Distributed", "NGGT"))
  all_models_merged_material_demand$technology <- gsub("NGCC", "Gas", all_models_merged_material_demand$technology)
  all_models_merged_material_demand$model <- current_model

  # Append to the combined dataframe
  if (nrow(all_models_combined) == 0) {
    all_models_combined <- all_models_merged_material_demand
  } else {
    all_models_combined <- bind_rows(all_models_combined, all_models_merged_material_demand)
  }
}

# all_models_combined now contains the results for all models
print(unique(all_models_combined$model))



```

```{r}

filter_test_df <- all_models_combined %>% filter(year == 2035) %>% select(Aluminum_max, Aluminum_mean, Aluminum_min, model,year,scenario,technology) %>% group_by (year,scenario,model) %>%   summarise(
    aluminum_max_sum = sum(Aluminum_max, na.rm = TRUE),
    aluminum_mean_sum = sum(Aluminum_mean, na.rm = TRUE),
    aluminum_min_sum = sum(Aluminum_min, na.rm = TRUE)
  )

technologies_to_sum <- c("Biomass", "Coal", "Hydro", "Gas", "Nuclear New", "onshore wind", "utility-scale solar pv")
columns_to_sum <- c("Aluminum_mean", "Aluminum_min", "Aluminum_max")

# Function to sum over the specified columns
sum_columns <- function(df, columns) {
  result <- df %>% 
    group_by(year, scenario, model) %>% 
    summarise(across(all_of(columns), sum, na.rm = TRUE))
  return(result)
}

# Filter the relevant technologies
filtered_df <- all_models_combined %>% filter(technology %in% technologies_to_sum)

# Sum the specified columns for each group
all_models_sum_df <- sum_columns(filtered_df, columns_to_sum)

# Filter for the year 2035
year_2035_df <- all_models_sum_df %>% filter(year == 2035)

# Find the mean model
mean_model <- year_2035_df %>% 
  slice(which.min(abs(Aluminum_mean - mean(Aluminum_mean)))) %>%
  select(model)

# Extract the model name
mean_model_name <- mean_model$model

# Find the max and min models
max_model <- year_2035_df %>% slice(which.max(Aluminum_max))
min_model <- year_2035_df %>% slice(which.min(Aluminum_min))

# Combine the model names
models_to_keep <- unique(c(mean_model_name, max_model$model, min_model$model))

# Filter the original summed DataFrame to keep only the selected models
filtered_models_sum_df <- all_models_sum_df %>% filter(model %in% models_to_keep)

# View the resulting DataFrame
print(filtered_models_sum_df)

```



```{r}
# Subset capacities dataframe for specific technologies and years
repeat_capacities_new <- subset(repeat_capacities_new, technology %in% repeat_technologies)
repeat_capacities_new <- subset(repeat_capacities_new, year %in% c(2025, 2030, 2035)) # Subset for specific years
names(repeat_capacities_new)[names(repeat_capacities_new) == "run.name"] <- "scenario"
repeat_capacities_new$scenario[repeat_capacities_new$scenario == 'ira_mid'] <- 'IRA'
repeat_capacities_new$scenario[repeat_capacities_new$scenario == 'baseline'] <- 'REF'
print(unique(repeat_capacities_new$technology))
#print(unique(repeat_materials_demand$technology))
# Material demand simulation for the first group of materials
i <- 1
#c("Terbium", "Tin", "Vanadium", "Yttrium", "Zinc","Aluminum", "Boron", "Cadmium", "Cement", "Chromium", "Copper", "Dysprosium", "Fiberglass","Gallium", "Germanium", "Glass")
invisible(
  for (material in c("Terbium", "Tin", "Vanadium", "Yttrium", "Zinc","Aluminum", "Boron", "Cadmium", "Cement", "Chromium", "Copper", "Dysprosium", "Fiberglass","Gallium", "Germanium", "Glass") ) {
    df_int <- subset(intensity_mean, Material %in% material)
    df_cap <- repeat_capacities_new %>% left_join(df_int, by = 'technology') 
    
    # Prevent negative values
    df_cap[df_cap < 0] <- 0
    
    # Calculate total demand considering min, max, and mean intensity
    df_cap$total_demand_mean <- df_cap$newval * df_cap$value
    df_cap$total_demand_min <- df_cap$newval * df_cap$min
    df_cap$total_demand_max <- df_cap$newval * df_cap$max
    
    colnames(df_cap)[colnames(df_cap) == "total_demand_mean"] <- paste0(material, "_mean")
    colnames(df_cap)[colnames(df_cap) == "total_demand_min"] <- paste0(material, "_min")
    colnames(df_cap)[colnames(df_cap) == "total_demand_max"] <- paste0(material, "_max")
    
    df_cap <- subset(df_cap, select = -c(Material, newval, value, min, max))
    
    if (i == 1) {
      repeat_materials_demand_group1 <- df_cap
    } else {
      repeat_materials_demand_group1 <- repeat_materials_demand_group1 %>% left_join(df_cap, by = c("scenario", "year", "technology"))
    }
    i <- i + 1
  }
)

# Material demand simulation for the second group of materials
i <- 1
invisible(
  for (material in c("Manganese", "Molybdenum", "Neodymium",  "Nickel", "Niobium", "Praseodymium", "Selenium", "Silicon", "Silver", "Steel", "Tellurium", "Indium", "Lead", "Magnesium"
)) {
    df_int <- subset(intensity_mean, Material %in% material)
    df_cap <- repeat_capacities_new %>% left_join(df_int, by = 'technology') 
    
    # Prevent negative values
    df_cap[df_cap < 0] <- 0
    
    # Calculate total demand considering min, max, and mean intensity
    df_cap$total_demand_mean <- df_cap$newval * df_cap$value
    df_cap$total_demand_min <- df_cap$newval * df_cap$min
    df_cap$total_demand_max <- df_cap$newval * df_cap$max
    
    colnames(df_cap)[colnames(df_cap) == "total_demand_mean"] <- paste0(material, "_mean")
    colnames(df_cap)[colnames(df_cap) == "total_demand_min"] <- paste0(material, "_min")
    colnames(df_cap)[colnames(df_cap) == "total_demand_max"] <- paste0(material, "_max")
    
    df_cap <- subset(df_cap, select = -c(Material, newval, value, min, max))
    
    if (i == 1) {
      repeat_materials_demand_group2 <- df_cap
    } else {
      repeat_materials_demand_group2 <- repeat_materials_demand_group2 %>% left_join(df_cap, by = c("scenario", "year", "technology"))
    }
    i <- i + 1
  }
)

# Merge the results for both groups
merged_material_demand <- merge(repeat_materials_demand_group1, repeat_materials_demand_group2, by = c("year", "scenario", "technology"))
repeat_materials_demand <- merged_material_demand

```

**Material demand simulation (using mean material intensity values and Jenkins et al. (2023) capacity):** This code simulates material demand using mean material intensity values and added capacities estimated based on Jenkins et al. (2023).


**Material intensity simulation (using material intensity distributions and Bistline et al. (2023) capacity):** This code simulates material demand using fitted material intensity distributions and added capacities estimated based on Bistline et al. (2023).

```{r}
materials <- c(unique(intensity$Material))
print(unique(intensity$technology))
print("----")
print(multi_model_technologies)
print(materials)
n <- 1 # number of iterations
df_mc <- data.frame() 
print(materials)
for (mat in materials) {
  for (tech in multi_model_technologies) {
    loc <- subset(intensity, Material %in% mat & technology %in% tech)
    if (nrow(loc) > 1) {
      
      tryCatch({
        distribution_info <- subset(distribution_fits, Material == mat & technology == tech)$Distribution
      }, error = function(e) {
        distribution_info <- NA
      })
      
      if (length(distribution_info) == 0) {  # Handle empty dataframe
        distribution_info <- NA
      }
      
      if (is.na(distribution_info)) {  # If no distribution info found, default to normal
        distribution_info <- "normal"
      }
      
      minv <- min(loc$value)
      maxv <- max(loc$value)
      meanv <- mean(loc$value)
      index_name <- paste(mat, gsub("[[:space:]]", ".", tech), sep = ".") # addressing issues with spaces and dashes
      index_name <- gsub("-", ".", index_name)
      df2 <- data.frame(index = index_name, min = minv, max = maxv, mean = meanv)
      
      if (n == 1) {
        mc_values <- df2
      } else {
        mc_values <- rbind(mc_values, df2)
      }
      
      # Generate values based on the distribution type
      if (distribution_info == "triangular") {
        result <- rtriangle(1000, minv, maxv, meanv)
      } else if (distribution_info == "gauss") {
        result <- rnorm(1000, mean = meanv, sd = (maxv - minv) / 6)
      } else if (distribution_info == "weibull") {
        result <- rweibull(1000, shape = 1.5, scale = meanv)
      } else if (distribution_info == "gamma") {
        result <- rgamma(1000, shape = 1.5, scale = meanv / 1.5)
      } else {
        warning(paste("Distribution", distribution_info, " Defaulting to normal distribution."))
        result <- rnorm(1000, mean = meanv, sd = (maxv - minv) / 6)
      }
      
      # Check if result is negative and replace with 0
      result[result < 0] <- 0
      
      if (n == 1) {
        df_mc <- data.frame(result)
      } else {
        df_mc <- cbind(df_mc, result)
      }
      colnames(df_mc)[colnames(df_mc) == "result"] <- index_name
      n <- n + 1
    }
  }
}
print(colnames(df_mc))
```


**Material demand simulation (using material intensity distributions and Jenkins et al. (2023) capacity):** This code simulates material demand using fitted material intensity distributions and added capacities estimated based on Jenkins et al. (2023).
```{r}

library(dplyr)
 capacities_new <- subset(multi_model_capacities, technology %in% multi_model_technologies)
 capacities_new <- subset(capacities_new, year %in% c(2021,2025, 2030, 2035)) # Subset for specific years

subset_capacities<- capacities_new 
# Process df_mc data
melted_df_mc <- df_mc %>%
  mutate(row_id = row_number()) %>%
  pivot_longer(cols = -row_id, names_to = "Material_Technology", values_to = "Intensity_Distribution_Value") %>%
  mutate(Technology = gsub("^[^.]+\\.", "", Material_Technology),  # Extract word after the first dot
         Technology = gsub("\\.", " ", Technology))  # Replace periods with spaces

melted_df_mc <- melted_df_mc %>%
  rename(technology = Technology)
melted_df_mc$technology <- gsub("utility scale solar pv", "utility-scale solar pv", melted_df_mc$technology)
print(unique(melted_df_mc$Material_Technology))

melted_df_mc <- melted_df_mc %>%
  filter(technology %in% multi_model_technologies)

subset_capacities <- subset_capacities %>%
     filter(technology %in% unique(melted_df_mc$technology))

melted_df_mc <- melted_df_mc %>%
  filter(technology %in% unique(subset_capacities$technology))

 mc_material_demand <- merge(melted_df_mc, subset_capacities, by = "technology")

print(unique(subset_capacities$technology))
print(unique(melted_df_mc$technology))

mc_material_demand$material_demand = mc_material_demand$Intensity_Distribution_Value *mc_material_demand$newval
mc_material_demand$material_demand <- ifelse(mc_material_demand$material_demand < 0, 0, mc_material_demand$material_demand)
mc_material_demand <- mc_material_demand %>%
  rename(capacity_new = newval)
mc_material_demand <- mc_material_demand %>%
  mutate(Material = str_extract(Material_Technology, "\\w+"))

```
```{r}
#same thing but for repeat
materials <- c(unique(intensity$Material))
print(materials)
n <- 1 # number of iterations
df_mc <- data.frame() 

for (mat in materials) {
  for (tech in repeat_technologies) {
    loc <- subset(intensity, Material %in% mat & technology %in% tech)
    if (nrow(loc) > 1) {
      
      tryCatch({
        distribution_info <- subset(distribution_fits, Material == mat & technology == tech)$Distribution
      }, error = function(e) {
        distribution_info <- NA
      })
      
      if (length(distribution_info) == 0) {  # Handle empty dataframe
        distribution_info <- NA
      }
      
      if (is.na(distribution_info)) {  # If no distribution info found, default to normal
        distribution_info <- "normal"
      }
      
      minv <- min(loc$value)
      maxv <- max(loc$value)
      meanv <- mean(loc$value)
      index_name <- paste(mat, gsub("[[:space:]]", ".", tech), sep = ".") # addressing issues with spaces and dashes
      index_name <- gsub("-", ".", index_name)
      df2 <- data.frame(index = index_name, min = minv, max = maxv, mean = meanv)
      
      if (n == 1) {
        mc_values <- df2
      } else {
        mc_values <- rbind(mc_values, df2)
      }
      
      # Generate values based on the distribution type
      if (distribution_info == "triangular") {
        result <- rtriangle(1000, minv, maxv, meanv)
      } else if (distribution_info == "gauss") {
        result <- rnorm(1000, mean = meanv, sd = (maxv - minv) / 6)
      } else if (distribution_info == "weibull") {
        result <- rweibull(1000, shape = 1.5, scale = meanv)
      } else if (distribution_info == "gamma") {
        result <- rgamma(1000, shape = 1.5, scale = meanv / 1.5)
      } else {
        warning(paste("Distribution", distribution_info, " Defaulting to normal distribution."))
        result <- rnorm(1000, mean = meanv, sd = (maxv - minv) / 6)
      }
      
      # Check if result is negative and replace with 0
      result[result < 0] <- 0
      
      if (n == 1) {
        df_mc <- data.frame(result)
      } else {
        df_mc <- cbind(df_mc, result)
      }
      colnames(df_mc)[colnames(df_mc) == "result"] <- index_name
      n <- n + 1
    }
  }
}
```


```{r}
library(dplyr)

subset_capacities<- repeat_capacities_new 
# Process df_mc data
melted_df_mc <- df_mc %>%
  mutate(row_id = row_number()) %>%
  pivot_longer(cols = -row_id, names_to = "Material_Technology", values_to = "Intensity_Distribution_Value") %>%
  mutate(Technology = gsub("^[^.]+\\.", "", Material_Technology),  # Extract word after the first dot
         Technology = gsub("\\.", " ", Technology))  # Replace periods with spaces

# Rename column to 'technology'
melted_df_mc <- melted_df_mc %>%
  rename(technology = Technology)
melted_df_mc$technology <- gsub("utility scale solar pv", "utility-scale solar pv", melted_df_mc$technology)


melted_df_mc <- melted_df_mc %>%
  filter(technology %in% c("utility-scale solar pv", "onshore wind", "offshore wind", "Nuclear New", "Gas"))
print(repeat_technologies)
# Filter subset_capacities to include only technologies found in melted_df_mc
subset_capacities <- subset_capacities %>%
  filter(technology %in% unique(melted_df_mc$technology))

melted_df_mc <- melted_df_mc %>%
  filter(technology %in% unique(subset_capacities$technology))

 repeat_mc_material_demand <- merge(melted_df_mc, subset_capacities, by = "technology")

print(unique(subset_capacities$technology))
print(unique(melted_df_mc$technology))

repeat_mc_material_demand$material_demand = repeat_mc_material_demand$Intensity_Distribution_Value *repeat_mc_material_demand$newval
repeat_mc_material_demand$material_demand <- ifelse(repeat_mc_material_demand$material_demand < 0, 0, repeat_mc_material_demand$material_demand)
repeat_mc_material_demand <- repeat_mc_material_demand %>%
  rename(capacity_new = newval)
repeat_mc_material_demand <- repeat_mc_material_demand %>%
  mutate(Material = str_extract(Material_Technology, "\\w+"))

print(unique(repeat_mc_material_demand$technology))
```

```{r}
library(dplyr)
library(tidyr)
print(unique(mc_material_demand$Material_Technology))
mc_material_demand_total <- mc_material_demand %>%
  select(-capacity_new, -Intensity_Distribution_Value) %>%  # Exclude irrelevant columns
  pivot_wider(
    id_cols = c(row_id, year, scenario, Material),  # Include identifiers
    names_from = technology, 
    values_from = material_demand,
    values_fill = 0  # Fill missing values with 0
  )
mc_material_demand_total <- mc_material_demand_total %>%
  mutate(
    total_demand = rowSums(select(., 
                                   c(Biomass, 'Bio CCS', Coal, 'Coal CCS', 'Gas CCS', NGGT,NGCC, Hydro, `Nuclear New`, `onshore wind`, `utility-scale solar pv`,'Solar Distributed')))
  )
subset_data <- mc_material_demand_total %>%
  filter(Material == "Steel", scenario == "IRA", year == 2035) %>% mutate(total_demand = rowSums(select(., 
                                   c(Biomass, 'Bio CCS', Coal, 'Coal CCS', 'Gas CCS', NGGT,NGCC, Hydro, `Nuclear New`, `onshore wind`, `utility-scale solar pv`,'Solar Distributed')))
  )

repeat_mc_material_demand_total <- repeat_mc_material_demand %>%
  select(-capacity_new, -Intensity_Distribution_Value) %>%  # Exclude irrelevant columns
  pivot_wider(
    id_cols = c(row_id, year, scenario, Material),  # Include identifiers
    names_from = technology, 
    values_from = material_demand,
    values_fill = 0  # Fill missing values with 0
  )
print(unique(repeat_mc_material_demand$technology))
repeat_mc_material_demand_total <- repeat_mc_material_demand_total %>%
  mutate(
    total_demand = rowSums(select(., 
                                   c(`Gas`, `Nuclear New`, `onshore wind`, `offshore wind`, `utility-scale solar pv`)))
  )


unique(repeat_mc_material_demand$technology)
```
```{r}

library(dplyr)

#repeat_materials_demand <- repeat_materials_demand %>%
  #mutate_at(vars(4:50), ~ ./1000)

#repeat_mc_material_demand_total <-repeat_mc_material_demand_total%>%
 # mutate_at(vars(5:10), ~ ./1000)
# Now columns 5 to 11 have all their values divided by 1000

```

**Saving data frames to "outputs" folder:** This code saves the dataframes for use in the model 

```{r}
folder_path <- "C:/Users/avery/OneDrive/Desktop/MaterialDemand/Outputs"
file_path2 <- file.path(folder_path, "simulated_intensity")
file_path3 <- file.path(folder_path, "multi_model_mc_material_demand.csv")
file_path4 <- file.path(folder_path, "repeat_mc_material_demand.csv")
file_path5 <- file.path(folder_path, "materials_demand.csv")
file_path6 <- file.path(folder_path, "repeat_materials_demand.csv")
file_path7 <- file.path(folder_path, "repeat_mc_material_demand_total.csv")
file_path8 <- file.path(folder_path, "multi_model_mc_material_demand_total.csv")
file_path9 <- file.path(folder_path, "intensity_mean.csv")
file_path10 <- file.path(folder_path, "all_models_material_demand.csv")

unique(mc_material_demand_total$Material)

# Write each dataframe to its respective CSV file in the specified folder
write.csv(df_mc, file = file_path2, row.names = FALSE)

write.csv(mc_material_demand, file = file_path3, row.names = FALSE)
write.csv(repeat_mc_material_demand, file = file_path4, row.names = FALSE)
write.csv(materials_demand, file = file_path5, row.names = FALSE)
write.csv(repeat_materials_demand, file = file_path6, row.names = FALSE)
write.csv(repeat_mc_material_demand_total, file = file_path7, row.names = FALSE)
write.csv(mc_material_demand_total, file = file_path8, row.names = FALSE)
write.csv(intensity_mean, file = file_path9, row.names = FALSE)
write.csv(all_models_combined, file = file_path10, row.names = FALSE)
test2 <- mc_material_demand %>% subset(Material %in% "Aluminum" & year %in% 2035 & scenario %in% "IRA"& technology %in% "utility-scale solar pv") %>% summarise(mean = mean(material_demand))
print(test2/1000)
print(unique(mc_material_demand$technology))

y <- mc_material_demand_total %>% subset(Material %in% "Aluminum" & year %in% 2035 & scenario %in% "IRA")%>% select("utility-scale solar pv")
```
```
```{r}
```



Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
