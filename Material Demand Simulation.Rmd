---
title: "Material Demand Calculations"
author: "Avery Moorhead"
date: "`12/22/23"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = "C:/Users/avery/OneDrive/Desktop/MaterialDemand/Inputs")

###NTS: Currently only running this script on aluminum cement and steel. you can change this by changing rows 222,305, and 341
#Clear objects from workspace
rm(list = ls())
#Load libraries
library(readxl)
library(data.table)
library(dplyr)
library(tidyverse)
library(triangle)
library(stringr)
library(knitr)

```

**Setup** Reading data Frames from "Capacities" and "Material Intensity. Defining technologies and scenarios


```{r message=FALSE, warning=FALSE}
# Print the current working directory
print(getwd())
input_usgs<- read.csv("input_usgs.csv")
material_intensity<- read.csv("intensity_data.csv")
initial_year<- read.csv("initial_year.csv")
multi_model_capacities<- read.csv("multi_model_capacities.csv")
repeat_capacities_new<- read.csv("repeat_capacities_new.csv")
distribution_fits<- read.csv("distribution_fitting_results.csv")

scenarios = c("Ref", "IRA")#Define the REPEAT scenarios to be included
repeat_technologies = c("onshore wind","utility-scale solar pv", "Nuclear New", "offshore wind","Coal","Geothermal","Biomass","Gas", "Hydro")
                        
                        #"Coal","Geothermal","Biomass","Gas", "Hydro")#Define the REPEAT technologies to be included
repeat_scenarios = c("baseline", "ira_mid")
usgs_variables = c("Consumption - US", "Production - US", "Import - US", "Export - US")


```

**Material intensity summary statistics and distribution fitting:** This code estimates summary statistics and fits probability distributions to material intensity data from Liang et al. (202X) and Wang et al. (202X).

```{r message=FALSE, warning=FALSE}
#materials <- c("Aluminum","Cement","Steel","Copper", "Silicon", "Indium","Neodymium","Silver","Dysprosium","Gallium","Selenium","Nickel","Manganese")
#print(materials)# Print the unique materials
#intensity = subset(material_intensity, Material %in% materials)
intensity = material_intensity 
materials <- c(unique(intensity$Material))
#Check if all material/technology scenarios are present, if not add 0.
for (material in materials) {
  for (tech in repeat_technologies){  
    check_empty_frame = subset(intensity, technology %in% tech & Material %in% material)
    if (nrow(check_empty_frame)==0){
      intensity[nrow(intensity) + 1,] <- list(tech, material, 0)
    }
  }
}

#Estimate summary statistics of material intensity data
intensity_mean_df = intensity%>% group_by(technology,Material) %>% summarise(max = max(value),min = min(value),value = mean(value)) 
intensity_mean <- subset(intensity_mean_df, technology %in% repeat_technologies) #take the mean of intensity values to get one value per tech/material combo.

intensity_mean <- intensity_mean %>%
  mutate_at(vars(value, min, max), ~ . / 1000)

```

**Material demand simulation (using mean material intensity values and Bistline et al. (2023) capacity):** This code simulates material demand using mean material intensity values and added capacities estimated based on Bistline et al. (2023).
```{r}
# Material demand simulation
 capacities_new <- subset(multi_model_capacities, technology %in% repeat_technologies)
 capacities_new <- subset(capacities_new, year %in% c(2021,2025, 2030, 2035)) # Subset for specific years
i <- 1
#print(unique(intensity_mean$Material))
Listofmaterials <-unique(intensity_mean$Material)
Listofmaterials <- unique(trimws(intensity_mean$Material))

invisible(
  for (material in c("Terbium", "Tin", "Vanadium", "Yttrium", "Zinc","Aluminum", "Boron", "Cadmium", "Cement", "Chromium", "Copper", "Dysprosium", "Fiberglass","Gallium", "Germanium", "Glass"
)) {
    #print(material)

   # material = "Aluminum"
    df_int <- subset(intensity_mean, Material %in% material)
    df_cap <- capacities_new %>% left_join(df_int, by = 'technology') 
    # Prevent negative values
    df_cap[df_cap < 0] <- 0

    
    # Calculate total demand considering min, max, and mean intensity
    df_cap$total_demand_mean <- df_cap$newval * df_cap$value
    df_cap$total_demand_min <- df_cap$newval * df_cap$min
    df_cap$total_demand_max <- df_cap$newval * df_cap$max
    
    colnames(df_cap)[colnames(df_cap) == "total_demand_mean"] <- paste0(material, "_mean")
    colnames(df_cap)[colnames(df_cap) == "total_demand_min"] <- paste0(material, "_min")
    colnames(df_cap)[colnames(df_cap) == "total_demand_max"] <- paste0(material, "_max")
    
    df_cap <- subset(df_cap, select = -c(Material, newval, value, min, max))


    if (i == 1) {
      materials_demand <- df_cap
    } else {
      materials_demand <- materials_demand %>% left_join(df_cap, by = c("scenario", "year", "technology"))
    }
    i <- i + 1
  }
)
i<-1
invisible(
  for (material in c("Manganese", "Molybdenum", "Neodymium",  "Nickel", "Niobium", "Praseodymium", "Selenium", "Silicon", "Silver", "Steel", "Tellurium", "Indium", "Lead", "Magnesium"
)) {
    #print(material)

   # material = "Aluminum"
    df_int <- subset(intensity_mean, Material %in% material)
    df_cap <- capacities_new %>% left_join(df_int, by = 'technology') 
    # Prevent negative values
    df_cap[df_cap < 0] <- 0

    
    # Calculate total demand considering min, max, and mean intensity
    df_cap$total_demand_mean <- df_cap$newval * df_cap$value
    df_cap$total_demand_min <- df_cap$newval * df_cap$min
    df_cap$total_demand_max <- df_cap$newval * df_cap$max
    
    colnames(df_cap)[colnames(df_cap) == "total_demand_mean"] <- paste0(material, "_mean")
    colnames(df_cap)[colnames(df_cap) == "total_demand_min"] <- paste0(material, "_min")
    colnames(df_cap)[colnames(df_cap) == "total_demand_max"] <- paste0(material, "_max")
    
    df_cap <- subset(df_cap, select = -c(Material, newval, value, min, max))


    if (i == 1) {
      materials_demand1 <- df_cap
    } else {
      materials_demand1 <- materials_demand1 %>% left_join(df_cap, by = c("scenario", "year", "technology"))
    }
    i <- i + 1
  }
)
merged_material_demand <- merge(materials_demand, materials_demand1, by = c("year", "scenario", "technology"))
materials_demand<-merged_material_demand
```


```{r}
# Subset capacities dataframe for specific technologies and years
repeat_capacities_new <- subset(repeat_capacities_new, technology %in% repeat_technologies)
repeat_capacities_new <- subset(repeat_capacities_new, year %in% c(2025, 2030, 2035)) # Subset for specific years
names(repeat_capacities_new)[names(repeat_capacities_new) == "run.name"] <- "scenario"
repeat_capacities_new$scenario[repeat_capacities_new$scenario == 'ira_mid'] <- 'IRA'
repeat_capacities_new$scenario[repeat_capacities_new$scenario == 'baseline'] <- 'REF'

# Material demand simulation for the first group of materials
i <- 1
#c("Terbium", "Tin", "Vanadium", "Yttrium", "Zinc","Aluminum", "Boron", "Cadmium", "Cement", "Chromium", "Copper", "Dysprosium", "Fiberglass","Gallium", "Germanium", "Glass")
invisible(
  for (material in c("Terbium", "Tin", "Vanadium", "Yttrium", "Zinc","Aluminum", "Boron", "Cadmium", "Cement", "Chromium", "Copper", "Dysprosium", "Fiberglass","Gallium", "Germanium", "Glass") ) {
    df_int <- subset(intensity_mean, Material %in% material)
    df_cap <- repeat_capacities_new %>% left_join(df_int, by = 'technology') 
    
    # Prevent negative values
    df_cap[df_cap < 0] <- 0
    
    # Calculate total demand considering min, max, and mean intensity
    df_cap$total_demand_mean <- df_cap$newval * df_cap$value
    df_cap$total_demand_min <- df_cap$newval * df_cap$min
    df_cap$total_demand_max <- df_cap$newval * df_cap$max
    
    colnames(df_cap)[colnames(df_cap) == "total_demand_mean"] <- paste0(material, "_mean")
    colnames(df_cap)[colnames(df_cap) == "total_demand_min"] <- paste0(material, "_min")
    colnames(df_cap)[colnames(df_cap) == "total_demand_max"] <- paste0(material, "_max")
    
    df_cap <- subset(df_cap, select = -c(Material, newval, value, min, max))
    
    if (i == 1) {
      repeat_materials_demand_group1 <- df_cap
    } else {
      repeat_materials_demand_group1 <- repeat_materials_demand_group1 %>% left_join(df_cap, by = c("scenario", "year", "technology"))
    }
    i <- i + 1
  }
)

# Material demand simulation for the second group of materials
i <- 1
invisible(
  for (material in c("Manganese", "Molybdenum", "Neodymium",  "Nickel", "Niobium", "Praseodymium", "Selenium", "Silicon", "Silver", "Steel", "Tellurium", "Indium", "Lead", "Magnesium"
)) {
    df_int <- subset(intensity_mean, Material %in% material)
    df_cap <- repeat_capacities_new %>% left_join(df_int, by = 'technology') 
    
    # Prevent negative values
    df_cap[df_cap < 0] <- 0
    
    # Calculate total demand considering min, max, and mean intensity
    df_cap$total_demand_mean <- df_cap$newval * df_cap$value
    df_cap$total_demand_min <- df_cap$newval * df_cap$min
    df_cap$total_demand_max <- df_cap$newval * df_cap$max
    
    colnames(df_cap)[colnames(df_cap) == "total_demand_mean"] <- paste0(material, "_mean")
    colnames(df_cap)[colnames(df_cap) == "total_demand_min"] <- paste0(material, "_min")
    colnames(df_cap)[colnames(df_cap) == "total_demand_max"] <- paste0(material, "_max")
    
    df_cap <- subset(df_cap, select = -c(Material, newval, value, min, max))
    
    if (i == 1) {
      repeat_materials_demand_group2 <- df_cap
    } else {
      repeat_materials_demand_group2 <- repeat_materials_demand_group2 %>% left_join(df_cap, by = c("scenario", "year", "technology"))
    }
    i <- i + 1
  }
)

# Merge the results for both groups
merged_material_demand <- merge(repeat_materials_demand_group1, repeat_materials_demand_group2, by = c("year", "scenario", "technology"))
repeat_materials_demand <- merged_material_demand

```

**Material demand simulation (using mean material intensity values and Jenkins et al. (2023) capacity):** This code simulates material demand using mean material intensity values and added capacities estimated based on Jenkins et al. (2023).

```{r message=FALSE, warning=FALSE}
# # Capacity dataframes subsetted for specific technologies and years
# repeat_capacities_new <- subset(repeat_capacities_new, technology %in% repeat_technologies)
# repeat_capacities_new <- subset(repeat_capacities_new, year %in% c(2025, 2030, 2035)) # Subset for specific years
# names(repeat_capacities_new)[names(repeat_capacities_new) == "run.name"] <- "scenario"
# repeat_capacities_new$scenario[repeat_capacities_new$scenario == 'ira_mid'] <- 'IRA'
# repeat_capacities_new$scenario[repeat_capacities_new$scenario == 'baseline'] <- 'REF'
# 
# # Material demand simulation
# # Material demand simulation
# i <- 1
# invisible(
#   for (material in materials) {
#     df_int <- subset(intensity_mean, Material %in% material)
#     df_cap <- repeat_capacities_new %>% left_join(df_int, by = 'technology') 
#     
#     # Prevent negative values
#     df_cap[df_cap < 0] <- 0
#     
#     # Calculate total demand considering min, max, and mean intensity
#     df_cap$total_demand_mean <- df_cap$newval * df_cap$value
#     df_cap$total_demand_min <- df_cap$newval * df_cap$min
#     df_cap$total_demand_max <- df_cap$newval * df_cap$max
#     
#     colnames(df_cap)[colnames(df_cap) == "total_demand_mean"] <- paste0(material, "_mean")
#     colnames(df_cap)[colnames(df_cap) == "total_demand_min"] <- paste0(material, "_min")
#     colnames(df_cap)[colnames(df_cap) == "total_demand_max"] <- paste0(material, "_max")
#     
#     df_cap <- subset(df_cap, select = -c(Material, newval, value, min, max))
#     
#     if (i == 1) {
#       repeat_materials_demand <- df_cap
#     } else {
#       repeat_materials_demand <- repeat_materials_demand %>% left_join(df_cap, by = c("scenario", "year", "technology"))
#     }
#     i <- i + 1
#   }
# )

```

**Material intensity simulation (using material intensity distributions and Bistline et al. (2023) capacity):** This code simulates material demand using fitted material intensity distributions and added capacities estimated based on Bistline et al. (2023).

```{r}
n <- 1 # number of iterations
df_mc <- data.frame() 

for (mat in materials) {
  for (tech in repeat_technologies) {
    loc <- subset(intensity, Material %in% mat & technology %in% tech)
    if (nrow(loc) > 1) {
      
      tryCatch({
        distribution_info <- subset(distribution_fits, Material == mat & technology == tech)$Distribution
      }, error = function(e) {
        distribution_info <- NA
      })
      
      if (length(distribution_info) == 0) {  # Handle empty dataframe
        distribution_info <- NA
      }
      
      if (is.na(distribution_info)) {  # If no distribution info found, default to normal
        distribution_info <- "normal"
      }
      
      minv <- min(loc$value)
      maxv <- max(loc$value)
      meanv <- mean(loc$value)
      index_name <- paste(mat, gsub("[[:space:]]", ".", tech), sep = ".") # addressing issues with spaces and dashes
      index_name <- gsub("-", ".", index_name)
      df2 <- data.frame(index = index_name, min = minv, max = maxv, mean = meanv)
      
      if (n == 1) {
        mc_values <- df2
      } else {
        mc_values <- rbind(mc_values, df2)
      }
      
      # Generate values based on the distribution type
      if (distribution_info == "triangular") {
        result <- rtriangle(100, minv, maxv, meanv)
      } else if (distribution_info == "gauss") {
        result <- rnorm(100, mean = meanv, sd = (maxv - minv) / 6)
      } else if (distribution_info == "weibull") {
        result <- rweibull(100, shape = 1.5, scale = meanv)
      } else if (distribution_info == "gamma") {
        result <- rgamma(100, shape = 1.5, scale = meanv / 1.5)
      } else {
        warning(paste("Distribution", distribution_info, " Defaulting to normal distribution."))
        result <- rnorm(100, mean = meanv, sd = (maxv - minv) / 6)
      }
      
      # Check if result is negative and replace with 0
      result[result < 0] <- 0
      
      if (n == 1) {
        df_mc <- data.frame(result)
      } else {
        df_mc <- cbind(df_mc, result)
      }
      colnames(df_mc)[colnames(df_mc) == "result"] <- index_name
      n <- n + 1
    }
  }
}

```


**Material demand simulation (using material intensity distributions and Jenkins et al. (2023) capacity):** This code simulates material demand using fitted material intensity distributions and added capacities estimated based on Jenkins et al. (2023).
```{r}

library(dplyr)

subset_capacities<- capacities_new 
# Process df_mc data
melted_df_mc <- df_mc %>%
  mutate(row_id = row_number()) %>%
  pivot_longer(cols = -row_id, names_to = "Material_Technology", values_to = "Intensity_Distribution_Value") %>%
  mutate(Technology = gsub("^[^.]+\\.", "", Material_Technology),  # Extract word after the first dot
         Technology = gsub("\\.", " ", Technology))  # Replace periods with spaces

# Rename column to 'technology'
melted_df_mc <- melted_df_mc %>%
  rename(technology = Technology)
melted_df_mc$technology <- gsub("utility scale solar pv", "utility-scale solar pv", melted_df_mc$technology)


# Filter melted_df_mc to include only repeat technologies and remove "Wind Offshore"
melted_df_mc <- melted_df_mc %>%
  filter(technology %in% repeat_technologies)

# Filter subset_capacities to include only technologies found in melted_df_mc
subset_capacities <- subset_capacities %>%
  filter(technology %in% unique(melted_df_mc$technology))

melted_df_mc <- melted_df_mc %>%
  filter(technology %in% unique(subset_capacities$technology))

 mc_material_demand <- merge(melted_df_mc, subset_capacities, by = "technology")

print(unique(subset_capacities$technology))
print(unique(melted_df_mc$technology))

mc_material_demand$material_demand = mc_material_demand$Intensity_Distribution_Value *mc_material_demand$newval
mc_material_demand$material_demand <- ifelse(mc_material_demand$material_demand < 0, 0, mc_material_demand$material_demand)
mc_material_demand <- mc_material_demand %>%
  rename(capacity_new = newval)
mc_material_demand <- mc_material_demand %>%
  mutate(Material = str_extract(Material_Technology, "\\w+"))


```
```{r}
library(dplyr)

subset_capacities<- repeat_capacities_new 
# Process df_mc data
melted_df_mc <- df_mc %>%
  mutate(row_id = row_number()) %>%
  pivot_longer(cols = -row_id, names_to = "Material_Technology", values_to = "Intensity_Distribution_Value") %>%
  mutate(Technology = gsub("^[^.]+\\.", "", Material_Technology),  # Extract word after the first dot
         Technology = gsub("\\.", " ", Technology))  # Replace periods with spaces

# Rename column to 'technology'
melted_df_mc <- melted_df_mc %>%
  rename(technology = Technology)
melted_df_mc$technology <- gsub("utility scale solar pv", "utility-scale solar pv", melted_df_mc$technology)


# Filter melted_df_mc to include only repeat technologies and remove "Wind Offshore"
melted_df_mc <- melted_df_mc %>%
  filter(technology %in% repeat_technologies)

# Filter subset_capacities to include only technologies found in melted_df_mc
subset_capacities <- subset_capacities %>%
  filter(technology %in% unique(melted_df_mc$technology))

melted_df_mc <- melted_df_mc %>%
  filter(technology %in% unique(subset_capacities$technology))

 repeat_mc_material_demand <- merge(melted_df_mc, subset_capacities, by = "technology")

print(unique(subset_capacities$technology))
print(unique(melted_df_mc$technology))

repeat_mc_material_demand$material_demand = repeat_mc_material_demand$Intensity_Distribution_Value *repeat_mc_material_demand$newval
repeat_mc_material_demand$material_demand <- ifelse(repeat_mc_material_demand$material_demand < 0, 0, repeat_mc_material_demand$material_demand)
repeat_mc_material_demand <- repeat_mc_material_demand %>%
  rename(capacity_new = newval)
repeat_mc_material_demand <- mc_material_demand %>%
  mutate(Material = str_extract(Material_Technology, "\\w+"))



```

```{r}
library(dplyr)
library(tidyr)

mc_material_demand_total <- mc_material_demand %>%
  select(-capacity_new, -Intensity_Distribution_Value) %>%  # Exclude irrelevant columns
  pivot_wider(
    id_cols = c(row_id, year, scenario, Material),  # Include identifiers
    names_from = technology, 
    values_from = material_demand,
    values_fill = 0  # Fill missing values with 0
  )
mc_material_demand_total <- mc_material_demand_total %>%
  mutate(
    total_demand = rowSums(select(., 
                                   c(Coal, Gas, Hydro, `Nuclear New`, `onshore wind`, `utility-scale solar pv`)))
  )
repeat_mc_material_demand_total <- repeat_mc_material_demand %>%
  select(-capacity_new, -Intensity_Distribution_Value) %>%  # Exclude irrelevant columns
  pivot_wider(
    id_cols = c(row_id, year, scenario, Material),  # Include identifiers
    names_from = technology, 
    values_from = material_demand,
    values_fill = 0  # Fill missing values with 0
  )
repeat_mc_material_demand_total <- repeat_mc_material_demand_total %>%
  mutate(
    total_demand = rowSums(select(., 
                                   c(Coal, Gas, Hydro, `Nuclear New`, `onshore wind`, `utility-scale solar pv`)))
  )


unique(mc_material_demand_total$Material)
```
```{r}

library(dplyr)

#repeat_materials_demand <- repeat_materials_demand %>%
  #mutate_at(vars(4:50), ~ ./1000)

mc_material_demand_total<- mc_material_demand_total %>%
  mutate_at(vars(5:11), ~ ./1000)
repeat_mc_material_demand_total <-repeat_mc_material_demand_total%>%
  mutate_at(vars(5:11), ~ ./1000)
# Now columns 5 to 11 have all their values divided by 1000

```

**Saving data frames to "outputs" folder:** This code saves the dataframes for use in the model 

```{r}
folder_path <- "C:/Users/avery/OneDrive/Desktop/MaterialDemand/Outputs"
file_path2 <- file.path(folder_path, "simulated_intensity")
file_path3 <- file.path(folder_path, "multi_model_mc_material_demand.csv")
file_path4 <- file.path(folder_path, "repeat_mc_material_demand.csv")
file_path5 <- file.path(folder_path, "materials_demand.csv")
file_path6 <- file.path(folder_path, "repeat_materials_demand.csv")
file_path7 <- file.path(folder_path, "repeat_mc_material_demand_total.csv")
file_path8 <- file.path(folder_path, "multi_model_mc_material_demand_total.csv")

unique(mc_material_demand_total$Material)

# Write each dataframe to its respective CSV file in the specified folder
write.csv(df_mc, file = file_path2, row.names = FALSE)

write.csv(mc_material_demand, file = file_path3, row.names = FALSE)
write.csv(repeat_mc_material_demand, file = file_path4, row.names = FALSE)
write.csv(materials_demand, file = file_path5, row.names = FALSE)
write.csv(repeat_materials_demand, file = file_path6, row.names = FALSE)
write.csv(repeat_mc_material_demand_total, file = file_path7, row.names = FALSE)
write.csv(mc_material_demand_total, file = file_path8, row.names = FALSE)


```
```



Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
